https://react.vlpt.us/

*리액트란 무엇인가
리액트는 페이스북에서 개발하고 관리하는 UI 라이브러리
UI를 자동으로 업데이트 해준다
UI = render(state) // 상태가 변하면 UI도 변경
가상 돔을 통해서 UIf빠르게 업데이트 한다
함수형 프로그래밍을 적극적으로 활용한다

리액트 제약 사항
    렌더 함수는 순수 함수로 작성해야 한다 -> state가 변하지 않으면 항상 같은 값 리턴
    컴포넌트 상탯값은 불변 객체로 관리해야 한다 -> 기존 값 변경이 아니라 새로운 객체 생성

*바벨
바벨은 자바스크립트 코드를 변환해 주는 컴파일러
최신 자바스크립트 문법을 지원하지 않는 환경에서도 최신 문법을 사용
ES6 문법 사용 가능
JSX 문법 사용 가능
npm install @babel/core @babel/cli @babel/preset-react 

*폴리필
npm install core-js
새로운 자바스크립트 표준은 빌드시점에 바벨에 의해 주입된다
폴리필은 새로운 객체/함수가 현재 주입이 가능한지를 체크한다

*CSS
css-module : 컴포넌트 단위로 스타일 적용
sass : 별도의 문법을 이용. 변수를 사용하여 중복 제거
css-in-js : css 코드를 자바스크립트 파일 안에서 작성

*단일 페이지 애플리케이션
최초 요청 시 서버에서 첫 페이지를 처리하고 이후의 라우팅은 클라이언트엣 처리하는 웹 애플리케이션
페이지 전환에 의한 렌더링을 클라이언트에서 처리

*브라우저 히스토리 API
단일 페이지 애플리케이션 구현이 가능하려면 두 가지 기능 필요
1)자바스크립트에서 브라우저로 페이지 전환 요청을 보낼 수 있다. 브라우저는 서버로 요청을 보내지 않아야 한다
2)브라우저의 뒤로 가기와 같은 사용자의 페이지 전환 요청을 자바스크립트에서 처리할 수 있다. 이때도 브라우저는 서버로 요청을 보내지 않아야 한다
pustState,replaceState,popState이벤트로 처리한다

*react-router-dom
내부적으로 브라우저 히스토리 API사용

*ES6
ECMA에서 2015년에 채택한 자바스크립트 표준
1.변수
    1) var의 문제점
        함수 스코프, 호이스팅 후 참조 가능, 변수 재정의 가능
    2) const,let
        블록 스코프, 호이스팅 후 참조 불가능, 변수 재정의 불가능
2.객체 배열
    1) 단축 속성명,계산된 속성명
        function makePerson(age,name){
            return {age,name}
        }
    2) 계산된 속성명
        function makePerson(key,value){
            return {[key]:value}
        }
    3) 전개 연산자
        const numbers = [1,3,7,9]
        Max.max(...numbers)
        const obj1 = {age:23,name:'mike'}
        const obj2 = {...obj1}
    4) 배열 비구조화 : 여러 속성값을 변수로 쉽게 할당
        const arr = [1,2,3]
        const [a,b,c] = arr
        const [first,...rest1] = arr    // rest1=[2,3]
    5) 객체 비구조화
        const obj = {age:21,name:'mike'}
        const {age,name} = obj
3. 함수
    1) 매개변수 기본값 지원
    2) 나머지 매개변수
        function printLog(a,...rest){
        }
        printLog(1,2,3,4)
    3) 화살표 함수
        const add = (a,b) => {}
    4) 클로저 : 함수가 생성되는 시점에 접근 가능했던 변수들을 이후에도 계속해서 접근하는 기능
        function makeAddFunc(x){
            function add(y){
                return x+y
            }
        }
4. 프로미스
프로미스는 세 가지 상태 중 하나의 상태로 존재
대기 중 : 결과를 기다리는 중
이행됨 : 수행이 정상적으로 끝났고 결과값을 갖고 있음
거부됨 : 수행이 비정상적으로 끝났음
    1) 프로미스 생성
        const p1 = new Promise((resolve,reject)=>{})        // 프로미스는 대기 중 상태로 변경
        const p2 = Promise.reject('error message')
        const p3 = Promise.resolve(param)
    2) 프로미스 실행
        Promise.resolve(123).then(data=>console.log(data))  // 123
    3) Promise.all : Promise 병렬 처리
        requestData1().then(data=>{         // 순차적 비동기 코드
            return requestData2()
        }).then(data=>{
            consoloe.log(data)          
        })

        Promise.all([requestData1(),requestData2()].then([data1,data2])=>{

        })
    4) Promise.race : 여러개 Promise 중 빨리 처리된 Promise 반환
    5) async/await : async/await 함수는 프로미스를 반환
        async function getData(){
            const data1 = await asyncFunc1()
            const data2 = await asyncFunc2()
        }
5. 템플릿 리터럴 : 동적 문자열 생성
    const smg = `name:${name}`
    const result = taggedFunc`a ${v1} b${v2}}`  // 태그된 템플릿 리터럴
    function taggedFUnc(strings,...expressions){}
6. 제너레이터 : 함수의 실행을 중간에 멈추고 재개할 수 있는 기능
    function* f1(){
        console.log(`f1-1')
        yield 10
        console.log(`f1-2')
        yield 20
        console.log(`f1-3')
        return 'finished'
    }
    const gen = f1()    // f1-1
    gen.next()          // f1-2
    get.next()          // f1-3
    get.next()
7. 리액트 요소와 가상 돔 
    컴포넌트의 상태값 = 해당 컴포넌트가 관리하는 데이터. 불변 객체는 아니지만 불변으로 관리하는게 유리
    컴포넌트의 속성값 = 부모 컴포넌트로부터 전달받는 데이터. 불변 객체
    setState : 클래스형 컴포넌트에서 상태값을 변경할 때 호출하는 메서드
    리액트 요소가 돔 요소로 만들어지는 과정
        1) 렌더 단계 : 실제 돔에 반영할 변경 사항을 파악
        2) 커밋 단계 : 파악된 변경 사항을 실제 돔에 반영
8. 생명주기
    1) 초기화 단계 : 최초에 컴포넌트 객체가 생성될 때 한 번 수행
        constructor()
        getDerivedStateFromProps() : 속성값을 이용해서 새로운 상태값을 만들 때 사용
        render() : 컴포넌트 정의시 반드시 작성. 화면에 보여질 내용 결정
        componentDidMount() 
    2) 업데이트 단계 : 초기화 단계와 소멸 단계 사이에서 반복해서 수행
        getDerivedStateFromProps()
        shouldComponentUpdate() : 성능 최적화를 위해 존재
        render()
        getSnapshotBeforeUpdate() : 렌더링 결과가 실제 돔에 반영되기 직전에 호출
        componentDidUpdate() : 가상 돔이 실제 돔에 반영된 후 호출
    3) 소멸 단계
        componentWillUnmount() : 끝나지 않은 네트워크 요청 취소, 타이머 해제, 구독 해제 등 작업
9. 컨텍스트 API
    React.createContext(defaultValue)=>{Provider,Consumer}
    하위 컴포넌트에서 콘텍스트 데이터 수정 가능하도록 함수 전달
10. ref
    돔 요소에 접근해야할때 ref 사용
    forwardRef : 부모 컴포넌트에서 넘어온 ref 속성값을 직접 처리
11. 컴포넌트 작성
    1) 코드 그룹핑
    2) 함수형 컴포넌트 자것ㅇ
    3) 속성값 타입 정의 : prop-types
    4) 조건부 렌더링
    5) 프레젠테이션/컨테이너 컴포넌트 구분
12. 렌더링 성능 최적화
    1) 상태값을 불변 객체로 관리
    2) 렌더 함수에서 새로운 객체 만들지 않기
    3) 메모제이션 이용
13. 리액트 훅
    함수형 컴포넌트에서도 클래스형 컴포넌트의 기능을 사용할 수 있게 하는 기능
    훅을 통해서 함수형 컴포넌트에서도 컴포넌트의 상태값을 관리
    재사용 가능한 로직을 쉽게 구현
    useState : 상태값 관리
    useEffect : 생명 주기 함수
        useEffect(()=>{
            const onResize = () => setWidth(window.inner)
            window.addEventListener('resize',onResize)
            return ()=>{window.removeEventListener('resize',onResize)}              // unmount시 호출
        },[])
    useContext : Consumer 컴포너트를 사용하지 않고도 부모 컴포넌트로부터 전달된 데이터 사용 가능
    useRef : 돔 요소 접근
    useMemo : 계산량이 많은 함수의 반환값을 재활용
    useCallback : 리액트 렌더링 성능을 위해 제공되는 훅
    useReducer : 컴포넌트의 상태값을 리덕스의 리듀서처럼 관리
    useImperativeHandle : 부모의 컴포넌트에 접근 가능
    useLayoutEffect : useEffect는 비동기로 호출되고 useLayoutEeffect는 동기로 호출 된다
    useDebugValue : 커스텀 훅 내부 관찰
    construcotr
        function Profile({first,last}){
            const isFirstRef = useRef(true)
            if(isFirstRef.current){
                callApi()   // 최초 1회
            }
        }
    
*리덕스로 상태 관리하기
    리덕스 : 자바스크립트를 위한 상태 관리 프레임워크
    1. 리덕스를 사용하는 이유
        1) 컴포넌트 코드로부터 상태 관리 코드를 분리할 수 있다
        2) 서버 렌더링 시 데이터 전달이 간편하다
        3) 로컬 스토리지에 데이터를 저장하고 불러오는 코드를 쉽게 작성
        4) 같은 상태값을 다수의 컴포넌트에서 필요로할 때 좋다
        5) 부모 컴포넌트에서 깊은 곳에 있는 자식 컴포넌트에 상태값을 전달할 때 좋다
        6) 알림창과 같은 전역 컴포넌트 상태값을 관리할 때 좋다
        7) 페이지가 전환되어도 데이터는 살아 있어야 할 때 좋다
    2. 리덕스 사용 원칙
        1) 전체 상태값을 하나의 객체에 저장한다
        2) 상태값은 불변 객체다
        3) 상태값은 순수 함수에 의해서만 변경되어야 한다
            리듀서 : 리덕스에서 상태값을 변경하는 함수
    3. 리덕스 주요 개념
        액션 -> 미들웨어 -> 리듀서 -> 스토어 -> 액션
        1) 액션 : type 속성을 가진 자바스크립트 객체
        2) 미들웨어 : 리듀서가 액션을 처리하기 전에 실행되는 함수
        3) 리듀서 : 액션이 발생했을 때 새로운 상태값을 만드는 함수
        4) 스토어 : 리덕스의 상태값을 갖는 객체
    const [state,dispatch] = useReducer(reducer, initialState)
        state : 상태
        dispatch : 액션을 발생시키는 함수
        reducer : 액션을 발생시키는 함수
        initialState : 초기 값

*바벨과 웹팩
    바벨 : 입력과 출력이 모두 자바스크립트 코드인 컴파일러
    바벨 실행 : @babel/core, @babel/ci, babel-loader
    폴리필 : 런타임에 기능을 주입하는 것
    웹팩 : 모듈 번들러
    모듈 : 각 리소스 파일, 번들러 : 웹팩 실행 후에 나오는 겨로가 파일
    로더 : 모듈을 입력으로 받아서 원하는 형태로 변환한 후 새로운 모듈을 출럭
*서버사이드 렌더링
    서버사이드 렌더링이 필요한 이유
        1) 검색 엔진 최적화
        2) 빠른 첫 페이지 렌더링 중요
